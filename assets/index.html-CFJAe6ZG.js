import{_ as a,c as n,d as e,o as i}from"./app-B50BTcOQ.js";const l={};function p(d,s){return i(),n("div",null,s[0]||(s[0]=[e(`<p>递归是一种编程技巧，函数直接或间接调用自身来解决问题。它的核心思想是将一个大问题分解成结构相同但规模更小的子问题，直到子问题足够简单可以直接求解（称为 “基准条件”），然后逐层返回结果组合成最终答案。</p><h2 id="递归的核心要素" tabindex="-1"><a class="header-anchor" href="#递归的核心要素"><span>递归的核心要素</span></a></h2><h3 id="基准条件-base-case" tabindex="-1"><a class="header-anchor" href="#基准条件-base-case"><span>基准条件 (Base Case)</span></a></h3><p>递归的终止条件。没有它，递归会无限循环导致栈溢出。</p><p>例如：计算阶乘 n! 时，定义 0! = 1 作为基准。</p><h3 id="递归步骤-recursive-step" tabindex="-1"><a class="header-anchor" href="#递归步骤-recursive-step"><span>递归步骤 (Recursive Step)</span></a></h3><p>将问题分解为更小的同类子问题，并调用自身解决。</p><p>例如：n! = n * (n-1)!</p><h2 id="递归能做什么-典型应用场景" tabindex="-1"><a class="header-anchor" href="#递归能做什么-典型应用场景"><span>递归能做什么？典型应用场景</span></a></h2><h3 id="数学计算" tabindex="-1"><a class="header-anchor" href="#数学计算"><span>数学计算</span></a></h3><ul><li><p>阶乘：fact (n) = n * fact (n-1)</p></li><li><p>斐波那契数列：fib (n) = fib (n-1) + fib (n-2)</p></li><li><p>汉诺塔问题：通过递归移动圆盘</p></li></ul><h3 id="遍历树形结构" tabindex="-1"><a class="header-anchor" href="#遍历树形结构"><span>遍历树形结构</span></a></h3><ul><li><p>文件系统遍历：列出文件夹及其子文件夹中的所有文件。</p></li><li><p>DOM 树操作：递归访问网页中的嵌套节点。</p></li><li><p>二叉树遍历：前序、中序、后序遍历（递归比循环更简洁）。</p></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>\\# 遍历文件夹的伪代码</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def list\\_files(directory):</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   for item in directory:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>       if item is a file:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>           print(item)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>       else:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>           list\\_files(item)  # 递归进入子文件夹</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="分治算法-divide-and-conquer" tabindex="-1"><a class="header-anchor" href="#分治算法-divide-and-conquer"><span>分治算法 (Divide and Conquer)</span></a></h3><ul><li><p>归并排序：将数组拆分成两半分别排序，再合并结果。</p></li><li><p>快速排序：选取基准值，递归排序子数组。</p></li></ul><h3 id="解决组合问题" tabindex="-1"><a class="header-anchor" href="#解决组合问题"><span>解决组合问题</span></a></h3><ul><li><p>生成全排列：如生成字符串的所有排列组合。</p></li><li><p>解决迷宫问题：递归尝试所有路径。</p></li></ul><h3 id="解析嵌套结构" tabindex="-1"><a class="header-anchor" href="#解析嵌套结构"><span>解析嵌套结构</span></a></h3><ul><li><p>JSON/XML 解析：处理嵌套的数据结构。</p></li><li><p>表达式求值：如计算 (1 + (2 * 3)) 这类嵌套表达式。</p></li></ul><h2 id="递归-vs-循环" tabindex="-1"><a class="header-anchor" href="#递归-vs-循环"><span>递归 vs. 循环</span></a></h2><table><thead><tr><th>特性</th><th>递归</th><th>循环</th></tr></thead><tbody><tr><td>代码简洁性</td><td>更简洁（适合问题天然递归的场景）</td><td>可能需复杂状态管理</td></tr><tr><td>性能</td><td>函数调用开销大，可能栈溢出</td><td>通常更高效</td></tr><tr><td>可读性</td><td>更贴近数学定义</td><td>直观但有时繁琐</td></tr><tr><td>适用问题</td><td>树、图、分治、嵌套结构</td><td>线性迭代任务</td></tr></tbody></table><p>⚠️ 注意：递归深度过大可能导致栈溢出（如 Python 默认递归深度约 1000 层）。可通过尾递归优化（部分语言支持）或改用循环 + 栈解决。</p><h2 id="一个简单例子-计算阶乘" tabindex="-1"><a class="header-anchor" href="#一个简单例子-计算阶乘"><span>一个简单例子：计算阶乘</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>def factorial(n):</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   if n == 0:  # 基准条件</span></span>
<span class="line"><span></span></span>
<span class="line"><span>       return 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   else:       # 递归步骤</span></span>
<span class="line"><span></span></span>
<span class="line"><span>       return n \\* factorial(n-1)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>print(factorial(5))  # 输出 120</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="何时使用递归" tabindex="-1"><a class="header-anchor" href="#何时使用递归"><span>何时使用递归？</span></a></h2><ul><li><p>问题可分解为多个相同结构的子问题。</p></li><li><p>子问题的规模不断缩小。</p></li><li><p>存在明确的基准条件。</p></li><li><p>代码简洁性比极致性能更重要（或问题规模可控）。</p></li></ul><p>递归是理解算法思想的利器，但在生产环境中需谨慎评估性能和栈深度限制！</p>`,28)]))}const r=a(l,[["render",p]]),c=JSON.parse('{"path":"/js/pk3omwda/","title":"什么是递归","lang":"zh-CN","frontmatter":{"title":"什么是递归","createTime":"2025/07/24 09:09:29","permalink":"/js/pk3omwda/"},"readingTime":{"minutes":2.46,"words":738},"git":{"createdTime":1753323973000,"updatedTime":1753323973000,"contributors":[{"name":"smileBoys2023","username":"smileBoys2023","email":"140247874+smileBoys2023@users.noreply.github.com","commits":1,"avatar":"https://avatars.githubusercontent.com/smileBoys2023?v=4","url":"https://github.com/smileBoys2023"}]},"filePathRelative":"notes/js/dg.md","headers":[]}');export{r as comp,c as data};
